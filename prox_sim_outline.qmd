---
title: "PROX Simulation Specs"
format: html
editor_options: 
  chunk_output_type: console
---

## PROX Simulation Outline

This simulation will compare the recovery of simulated ability parameters using different ability estimation functions with fixed item parameter estimates. The PROX method [@cohen1972] will be compared to:

-   Joint Maximum Likelihood Estimation (JMLE; TAM package) *Can use fixed item parameters*
-   Marginal Maximum Likelihood Estimation (MMLE; TAM or ltm package) *TAM uses EAP after MMLE*
-   Conditional Maximum Likelihood Estimation (CMLE; Winsteps) *Can use fixed item parameters, takes magnitudes longer than the other methods (\~2 minutes in condition 1)*
-   Expected a Posteriori estimator (EAP; irtoys package) *Uses LTM as the backend, can use fixed item parameters*

The comparisons between these estimation methods will look at different distributions of person abilities and different sample sizes of responses. The different levels of these factors are:

-   Parameter Distributions:
    -   Both items and persons: A standard normal distribution, $\theta \sim \mathcal{N}(\mu = 0, \sigma^2 = 1)$

    -   Both items and persons: $\theta \sim \mathcal{N}(0, 2)$

    -   Items = $\theta \sim \mathcal{N}(-1, 1)$ and Persons = $\theta \sim \mathcal{N}(1, 1)$

    -   Items = $\theta \sim \mathcal{N}(-2, 1)$ and Persons = $\theta \sim \mathcal{N}(2, 1)$

    -   Items = $\theta \sim \mathcal{N}(-3, 1)$ and Persons = $\theta \sim \mathcal{N}(3, 1)$

    -   Items = $\theta \sim \mathcal{N}(0, 1)$ and Persons = bimodal mixture distribution with equal $\sigma^2 = 0.5$ and modes $\mathcal{Mo}_1 = -1.5$ and $\mathcal{Mo}_2 = 1.5$
    -   Items = bimodal mixture distribution with equal $\sigma^2 = 0.5$ and modes $\mathcal{Mo}_1 = -1.5$ and $\mathcal{Mo}_2 = 1.5$ and Persons = $\theta \sim \mathcal{N}(0, 1)$
-   Person Sample sizes:
    -   $n = 25$
    -   $n = 50$
    -   $n = 100$
    -   $n = 200$
    -   $n = 500$
    -   $n = 1000$

Here is a table of each condition label and its parameter values.

```{r}
#| label: simulation-conditions-table

require(tidyverse, quietly = TRUE)
person_sample_sizes = c(25, 50, 100, 200, 500, 1000)
number_items = c(100, 150, 200)
parameter_distribution_condition = c("Standard Normal", "Wide Normal", "-1 Item Diff, +1 Person Theta", "-2 Item Diff, +2 Person Theta", "-3 Item Diff, +3 Person Theta", "Normal Items, Bimodal Persons", "Bimodal Items, Normal Persons")

conditions = expand.grid(person_sample_sizes, number_items, parameter_distribution_condition)
conditions = cbind(paste0("Condition ", 1:nrow(conditions)), conditions)
conditions = conditions[, c(1, 4, 3, 2)]
colnames(conditions) = c("Condition", "Item_and_Person_Params", "Items", "N")

conditions =
  conditions %>%
  mutate(
    Condition = 
      case_when(
        grepl(" [0-9]{1}$", Condition) ~ str_replace(Condition, "Condition ", "Condition 0")
    , TRUE ~ Condition
    )
  )
knitr::kable(conditions, col.names = c("Condition Number", "Item/Person Parameters", "Number of Items", "Number of Persons"))

conditions_save <- 
  conditions %>% 
  mutate(
    filename = 
      Condition %>%
      tolower() %>%
      str_replace(" ", "_") %>%
      str_replace("_0", "_") %>%
      paste0("_estimates.RDS")
    )

conditions_save %>%
  saveRDS("results/conditions.RDS")
```

## Creating the data

The following code chunk provides some setup for the simulation. It loads the required packages and defines functions to simulate the response data for analysis.

```{r setup}
require(TAM)
require(eRm)
require(irtoys)

iter = 100

rasch_response_sim = function(person_theta_value, item_diff_value) {
  resp_prob = exp(person_theta_value - item_diff_value) / (1 + exp(person_theta_value - item_diff_value))
  response = ifelse(
    test = runif(n = length(resp_prob)) <= resp_prob,
    yes = 1,
    no = 0)
  return(response)
}
prox_estimate = function(mean_item_diff, sd_item_diff, observed_raw_score, maximum_score) {
  estimate <-
    mean_item_diff + 
    sqrt(1 + sd_item_diff/2.9) * 
    log(observed_raw_score/(maximum_score - observed_raw_score))
  estimate <- 
    ifelse(estimate == Inf, 6,
           ifelse(estimate == -Inf, -6, 
                  estimate
                  )
           )
  estimate
}

winsteps_estimate = function(
    item_anchor_file = "sim.anchor",
    data_file = 'test.dat',
    scores_file = 'theta.out',
    data = NULL,
    item_params = items
    ) {
  require(tidyverse)
  # data file:
  test_data <-
    data %>%
    mutate(delim = "*", .after = 1) %>%
    pivot_wider(
      id_cols = c(id, delim)
      , names_from = item
      , values_from = response
    ) 
  
  test_data %>%
    write_delim(file = paste0('temp/', data_file), delim = '', col_names = FALSE)
  
  # item files:
  item_order <- 
    tibble(ItemID = colnames(test_data)[-c(1,2)])
  n_items = nrow(item_order)
  item_anchor_content <-
    item_order %>%
    left_join(
      item_params %>%
        dplyr::select(ItemID, IRTb) %>%
        distinct()
      ) %>%
    mutate(seq = row_number()) %>%
    dplyr::select(seq, IRTb, ItemID)
  item_anchor_content %>%
    mutate(delim = ";", .before = 3) %>%
    write_tsv(file = paste0('temp/', item_anchor_file), col_names = FALSE)
  
  # control file:
  control <-
    paste0(
'IAFILE=', item_anchor_file, ';
;******************************************
;Estimation & Convergence Criteria
;******************************************
MPROX=20                 	; Maximum of 20 PROX iterations
CMLE=Yes                  ; Use CMLE
;MJMLE=0                  ; Unlimited JMLE iterations
;XMLE=Yes                 ; Use XMLE=YES when calibrating items BUT XMLE=NO when computing person ability estimates
CONVERGE=L                ; 
LCONV=.0001               ; Stop iterating when the largest change is < 0.0001 logits
;RCONV=0.1               	; RCONV is not useful when anchor values are used. 
UDECIM=4                 	; Compute Estimates to 4 decimal places

TFILE=*
3.1
3.2
*;
;******************************************
;Input Data Format
;******************************************
CODES=01;
DATA=', data_file, ';
NAME1=1;
NAMLEN=4;
ITEM=Item;
ITEM1=6
NI=', n_items, ';
;******************************************
; Output Files
;******************************************
PFILE=', scores_file,';
;******************************************
; Item Labels
;******************************************
&END
', paste0(item_order$ItemID, collapse = ' \n'), '
END LABELS'
)
  control %>%
    write_lines('temp/overall_control.ctr')
  
  # .bat file
  paste0(
    'C:/Winsteps/Winsteps.exe	BATCH=YES "overall_control.ctr" '
    , '"OUT.csv" HLINES=YES'
  ) %>%
    write_lines('temp/winsteps_overall.bat')
  
  # run .bat
  system("cmd.exe",
         input = paste(' cd temp/ & winsteps_overall.bat'),
         show.output.on.console = FALSE)
}
winsteps_read_scores = function(scores_file = 'theta.out') {
  require(tidyverse)
  overall_scores <-
    read_table(file = paste0('temp/', scores_file)
               , show_col_types = FALSE
               , skip = 1) 
  if (nrow(overall_scores) == 0) {
    overall_scores <-
      tibble(
        RegID = NA, winsteps_answered = NA, winsteps_number_correct = NA
        , winsteps_estimate = NA, Exam = exam
        , winsteps_score = NA
      )
    } else {
      overall_scores <-
        overall_scores %>%
          dplyr::select(MEASURE) %>%
        unlist() %>%
        as.numeric()
    }
    return(overall_scores)
}

# options('warn' = 2)
```

Then, for each condition, we create the simulated item and person parameters and use the different estimation methods to estimate the person parameters based on the simulated data.

For PROX, a custom function using the formula [given on the Winsteps website](https://www.winsteps.com/winman/iterations.htm) was implemented.

For JMLE, the `tam.jml` function accepts the matrix of responses and, optionally, a matrix of item numbers (first column) and item difficulties (second column) to use as fixed values. This puts the focus on the *person parameter estimates* which is what we want for our simulation. The `$theta` element of the resulting list holds the estimated person parameters. Since the function does not automatically remove items with no correct responses, the simulation automatically removes these items (if they exist in the given iteration) and estimates person parameters based on the remaining items.

<!-- For MMLE, the `tam.mml` function behaves similarly. The output is different, however; we need to access `$person$EAP` to get the person theta estimates using the expected a posteriori of the marginal maximum likelihood estimator. Since some items may normally be removed due to the number of correct responses, we also specify `item.elim = FALSE` to keep these items in the analysis. -->
<!-- I forgot to actually include the mml EAP estimates in the final results, d'oh! -->

For CMLE, the Winsteps software is used. A custom function that manages the Winsteps control files and reads in the results was created as a simpler and more programmatic interface between the simulation conditions and Winsteps. With fixed item parameters, Winsteps is able to generate person parameters with CMLE; other common Rasch/IRT software does not seem to have this functionality.

<!-- For CMLE, the `eRm::RM` function takes the scored matrix and estimates the full model (item and person parameters) "simultaneously", so we can't provide the known item difficulties for this procedure. We also need to extract the person theta estimates with the `eRm::person.parameter` function, accessing the stored estimates in the output with `$theta.table$'Person Parameter'`. This does mean the CMLE estimates are not strictly comparable and may have additional estimation discrepancies. As the `eRm` package sometimes has issues with all correct/all incorrect response patterns, there is a wrapper function implemented that removes problematic items from the scored matrix when `eRm` throws an error and reruns the estimation process. -->

For EAP, the `irtoys` package provides an `eap()` estimator in the `ability()` function that can utilize the known item parameters. The first column of resulting matrix provides the ability estimates for each provided response pattern in the scoring matrix. Under the hood, it uses the `ltm` package by default.   

### Standard Normal

```{r condition-1}
#| eval: true
#| output: false
# Conditions 1-18 Parameters
Start.time = Sys.time()

m_item = m_person = 0
sd_item = sd_person = 1
estimates_file_name = 'simdata/01_standard_normal_estimates.RDS'
responses_file_name = 'simdata/01_standard_normal_responses.RDS'

condition_1_estimates = vector(mode = 'list', length = 18*iter)
condition_1_responses = vector(mode = 'list', length = 18*iter)
offset = 0

for (j in number_items) {
  print(paste0("Items: ", j))
  for (n in person_sample_sizes) {
    print(paste0("Persons: ", n))
    condition_name =
      tibble(
        Title = "Standard Normal"
        , ItemMean = m_item, ItemSD = sd_item
        , PersonMean = m_person, PersonSD = sd_person
        , N_Items = j
        , N_Person = n
        )
    for (i in 1:iter) {
      item_diff = round(rnorm(n = j, mean = m_item, sd = sd_item), 3)
      person_theta = rnorm(n = n, mean = m_person, sd = sd_person)

      responses = matrix(nrow = n, ncol = j)

      for (p in 1:n) {
        responses[p,] = rasch_response_sim(person_theta[p], item_diff)
      }

      zero_correct_items = which(colSums(responses) == 0 |
                                   colSums(responses) == n)
      if (length(zero_correct_items) > 0) {
        modified_responses = responses[, -zero_correct_items]
        modified_item_diff = item_diff[-zero_correct_items]
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      } else {
        modified_responses = responses
        modified_item_diff = item_diff
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      }

      prox_theta_est = prox_estimate(mean_item_diff = mean(item_diff),
                                     sd_item_diff = sd(item_diff),
                                     observed_raw_score = rowSums(responses),
                                     maximum_score = j)
      jmle_theta_est = TAM::tam.jml(
        modified_responses
        , xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff)
        , verbose = FALSE
      )$theta
      mmle_theta_est = TAM::tam.mml(
        modified_responses,
        xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff),
        item.elim = FALSE,
        verbose = FALSE
      )$person$EAP

      modified_responses %>%
        as_tibble() %>%
        mutate(
          id = paste0('00000', row_number()) %>% str_sub(-4, -1)
          , .before = 1
        ) %>%
        pivot_longer(
          cols = -id
          , names_to = 'item'
          , values_to = 'response'
        ) %>%
        winsteps_estimate(
          data = .
          , item_params = winsteps_item_diff
        )
      cmle_theta_est = winsteps_read_scores()

      eap_theta_est  =
        irtoys::ability(resp = modified_responses,
                        ip = list('est' = cbind(
                          1, modified_item_diff, 0, deparse.level = 0
                        )),
                        method = 'EAP')[, 1]

      thetas = cbind(person_theta,
                     prox_theta_est,
                     jmle_theta_est,
                     cmle_theta_est,
                     eap_theta_est)

      condition_1_estimates[[i+offset]] = list(Condition = condition_name, Theta = thetas)
      condition_1_responses[[i+offset]] = list(Condition = condition_name, ItemDiff = item_diff, Responses = responses)

      offset = offset + 1
    }
    
  }
}


saveRDS(condition_1_estimates, file = estimates_file_name)
saveRDS(condition_1_responses, file = responses_file_name)

```

`r Sys.time() - Start.time`

### Wide Normal

```{r condition-2}
#| eval: true
#| output: false
# Conditions 19-36 Parameters
Start.time = Sys.time()

m_item = m_person = 0
sd_item = sd_person = 2
estimates_file_name = 'simdata/02_wide_normal_estimates.RDS'
responses_file_name = 'simdata/02_wide_normal_responses.RDS'

condition_2_estimates = vector(mode = 'list', length = 18*iter)
condition_2_responses = vector(mode = 'list', length = 18*iter)
offset = 0

for (j in number_items) {
  print(paste0("Items: ", j))
  for (n in person_sample_sizes) {
    print(paste0("Persons: ", n))
    condition_name =
      tibble(
        Title = "Wide Normal"
        , ItemMean = m_item, ItemSD = sd_item
        , PersonMean = m_person, PersonSD = sd_person
        , N_Items = j
        , N_Person = n
        )
    for (i in 1:iter) {
      item_diff = round(rnorm(n = j, mean = m_item, sd = sd_item), 3)
      person_theta = rnorm(n = n, mean = m_person, sd = sd_person)

      responses = matrix(nrow = n, ncol = j)

      for (p in 1:n) {
        responses[p,] = rasch_response_sim(person_theta[p], item_diff)
      }

      zero_correct_items = which(colSums(responses) == 0 |
                                   colSums(responses) == n)
      if (length(zero_correct_items) > 0) {
        modified_responses = responses[, -zero_correct_items]
        modified_item_diff = item_diff[-zero_correct_items]
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      } else {
        modified_responses = responses
        modified_item_diff = item_diff
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      }

      prox_theta_est = prox_estimate(mean_item_diff = mean(item_diff),
                                     sd_item_diff = sd(item_diff),
                                     observed_raw_score = rowSums(responses),
                                     maximum_score = j)
      jmle_theta_est = TAM::tam.jml(
        modified_responses
        , xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff)
        , verbose = FALSE
      )$theta
      mmle_theta_est = TAM::tam.mml(
        modified_responses,
        xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff),
        item.elim = FALSE,
        verbose = FALSE
      )$person$EAP

      modified_responses %>%
        as_tibble() %>%
        mutate(
          id = paste0('00000', row_number()) %>% str_sub(-4, -1)
          , .before = 1
        ) %>%
        pivot_longer(
          cols = -id
          , names_to = 'item'
          , values_to = 'response'
        ) %>%
        winsteps_estimate(
          data = .
          , item_params = winsteps_item_diff
        )
      cmle_theta_est = winsteps_read_scores()

      eap_theta_est  =
        irtoys::ability(resp = modified_responses,
                        ip = list('est' = cbind(
                          1, modified_item_diff, 0, deparse.level = 0
                        )),
                        method = 'EAP')[, 1]

      thetas = cbind(person_theta,
                     prox_theta_est,
                     jmle_theta_est,
                     cmle_theta_est,
                     eap_theta_est)

      condition_2_estimates[[i+offset]] = list(Condition = condition_name, Theta = thetas)
      condition_2_responses[[i+offset]] = list(Condition = condition_name, ItemDiff = item_diff, Responses = responses)

      offset = offset + 1
    }
    
  }
}


saveRDS(condition_2_estimates, file = estimates_file_name)
saveRDS(condition_2_responses, file = responses_file_name)

```

### -1 Item +1 Theta

```{r condition-3}
#| eval: true
#| output: false
# Conditions 37-54 Parameters
Start.time = Sys.time()

m_item = -1; m_person = 1
sd_item = sd_person = 1
estimates_file_name = 'simdata/03_small_mismatch_estimates.RDS'
responses_file_name = 'simdata/03_small_mismatch_responses.RDS'

condition_3_estimates = vector(mode = 'list', length = 18*iter)
condition_3_responses = vector(mode = 'list', length = 18*iter)
offset = 0

for (j in number_items) {
  print(paste0("Items: ", j))
  for (n in person_sample_sizes) {
    print(paste0("Persons: ", n))
    condition_name =
      tibble(
        Title = "Small Mismatch"
        , ItemMean = m_item, ItemSD = sd_item
        , PersonMean = m_person, PersonSD = sd_person
        , N_Items = j
        , N_Person = n
        )
    for (i in 1:iter) {
      item_diff = round(rnorm(n = j, mean = m_item, sd = sd_item), 3)
      person_theta = rnorm(n = n, mean = m_person, sd = sd_person)

      responses = matrix(nrow = n, ncol = j)

      for (p in 1:n) {
        responses[p,] = rasch_response_sim(person_theta[p], item_diff)
      }

      zero_correct_items = which(colSums(responses) == 0 |
                                   colSums(responses) == n)
      if (length(zero_correct_items) > 0) {
        modified_responses = responses[, -zero_correct_items]
        modified_item_diff = item_diff[-zero_correct_items]
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      } else {
        modified_responses = responses
        modified_item_diff = item_diff
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      }

      prox_theta_est = prox_estimate(mean_item_diff = mean(item_diff),
                                     sd_item_diff = sd(item_diff),
                                     observed_raw_score = rowSums(responses),
                                     maximum_score = j)
      jmle_theta_est = TAM::tam.jml(
        modified_responses
        , xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff)
        , verbose = FALSE
      )$theta
      mmle_theta_est = TAM::tam.mml(
        modified_responses,
        xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff),
        item.elim = FALSE,
        verbose = FALSE
      )$person$EAP

      modified_responses %>%
        as_tibble() %>%
        mutate(
          id = paste0('00000', row_number()) %>% str_sub(-4, -1)
          , .before = 1
        ) %>%
        pivot_longer(
          cols = -id
          , names_to = 'item'
          , values_to = 'response'
        ) %>%
        winsteps_estimate(
          data = .
          , item_params = winsteps_item_diff
        )
      cmle_theta_est = winsteps_read_scores()

      eap_theta_est  =
        irtoys::ability(resp = modified_responses,
                        ip = list('est' = cbind(
                          1, modified_item_diff, 0, deparse.level = 0
                        )),
                        method = 'EAP')[, 1]

      thetas = cbind(person_theta,
                     prox_theta_est,
                     jmle_theta_est,
                     cmle_theta_est,
                     eap_theta_est)

      condition_3_estimates[[i+offset]] = list(Condition = condition_name, Theta = thetas)
      condition_3_responses[[i+offset]] = list(Condition = condition_name, ItemDiff = item_diff, Responses = responses)

      offset = offset + 1
    }
    
  }
}


saveRDS(condition_3_estimates, file = estimates_file_name)
saveRDS(condition_3_responses, file = responses_file_name)

```


### -2 Item +2 Theta

```{r condition-4}
#| eval: true
#| output: false
# Conditions 55-72 Parameters
Start.time = Sys.time()

m_item = -2; m_person = 2
sd_item = sd_person = 1
estimates_file_name = 'simdata/04_large_mismatch_estimates.RDS'
responses_file_name = 'simdata/04_large_mismatch_responses.RDS'

condition_4_estimates = vector(mode = 'list', length = 18*iter)
condition_4_responses = vector(mode = 'list', length = 18*iter)
offset = 0

for (j in number_items) {
  print(paste0("Items: ", j))
  for (n in person_sample_sizes) {
    print(paste0("Persons: ", n))
    condition_name =
      tibble(
        Title = "Large Mismatch"
        , ItemMean = m_item, ItemSD = sd_item
        , PersonMean = m_person, PersonSD = sd_person
        , N_Items = j
        , N_Person = n
        )
    for (i in 1:iter) {
      item_diff = round(rnorm(n = j, mean = m_item, sd = sd_item), 3)
      person_theta = rnorm(n = n, mean = m_person, sd = sd_person)

      responses = matrix(nrow = n, ncol = j)

      for (p in 1:n) {
        responses[p,] = rasch_response_sim(person_theta[p], item_diff)
      }

      zero_correct_items = which(colSums(responses) == 0 |
                                   colSums(responses) == n)
      if (length(zero_correct_items) > 0) {
        modified_responses = responses[, -zero_correct_items]
        modified_item_diff = item_diff[-zero_correct_items]
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      } else {
        modified_responses = responses
        modified_item_diff = item_diff
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      }

      prox_theta_est = prox_estimate(mean_item_diff = mean(item_diff),
                                     sd_item_diff = sd(item_diff),
                                     observed_raw_score = rowSums(responses),
                                     maximum_score = j)
      jmle_theta_est = TAM::tam.jml(
        modified_responses
        , xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff)
        , verbose = FALSE
      )$theta
      mmle_theta_est = TAM::tam.mml(
        modified_responses,
        xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff),
        item.elim = FALSE,
        verbose = FALSE
      )$person$EAP

      modified_responses %>%
        as_tibble() %>%
        mutate(
          id = paste0('00000', row_number()) %>% str_sub(-4, -1)
          , .before = 1
        ) %>%
        pivot_longer(
          cols = -id
          , names_to = 'item'
          , values_to = 'response'
        ) %>%
        winsteps_estimate(
          data = .
          , item_params = winsteps_item_diff
        )
      cmle_theta_est = winsteps_read_scores()

      eap_theta_est  =
        irtoys::ability(resp = modified_responses,
                        ip = list('est' = cbind(
                          1, modified_item_diff, 0, deparse.level = 0
                        )),
                        method = 'EAP')[, 1]

      thetas = cbind(person_theta,
                     prox_theta_est,
                     jmle_theta_est,
                     cmle_theta_est,
                     eap_theta_est)

      condition_4_estimates[[i+offset]] = list(Condition = condition_name, Theta = thetas)
      condition_4_responses[[i+offset]] = list(Condition = condition_name, ItemDiff = item_diff, Responses = responses)

      offset = offset + 1
    }
    
  }
}


saveRDS(condition_4_estimates, file = estimates_file_name)
saveRDS(condition_4_responses, file = responses_file_name)

```

### -3 Item +3 Theta

```{r condition-5}
#| eval: true
#| output: false
# Conditions 73-90 Parameters
Start.time = Sys.time()

m_item = -3; m_person = 3
sd_item = sd_person = 1
estimates_file_name = 'simdata/05_extreme_mismatch_estimates.RDS'
responses_file_name = 'simdata/05_extreme_mismatch_responses.RDS'

condition_5_estimates = vector(mode = 'list', length = 18*iter)
condition_5_responses = vector(mode = 'list', length = 18*iter)
offset = 0

for (j in number_items) {
  print(paste0("Items: ", j))
  for (n in person_sample_sizes) {
    print(paste0("Persons: ", n))
    condition_name =
      tibble(
        Title = "Extreme Mismatch"
        , ItemMean = m_item, ItemSD = sd_item
        , PersonMean = m_person, PersonSD = sd_person
        , N_Items = j
        , N_Person = n
        )
    for (i in 1:iter) {
      item_diff = round(rnorm(n = j, mean = m_item, sd = sd_item), 3)
      person_theta = rnorm(n = n, mean = m_person, sd = sd_person)

      responses = matrix(nrow = n, ncol = j)

      for (p in 1:n) {
        responses[p,] = rasch_response_sim(person_theta[p], item_diff)
      }

      zero_correct_items = which(colSums(responses) == 0 |
                                   colSums(responses) == n)
      if (length(zero_correct_items) > 0) {
        modified_responses = responses[, -zero_correct_items]
        modified_item_diff = item_diff[-zero_correct_items]
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      } else {
        modified_responses = responses
        modified_item_diff = item_diff
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      }

      prox_theta_est = prox_estimate(mean_item_diff = mean(item_diff),
                                     sd_item_diff = sd(item_diff),
                                     observed_raw_score = rowSums(responses),
                                     maximum_score = j)
      jmle_theta_est = TAM::tam.jml(
        modified_responses
        , xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff)
        , verbose = FALSE
      )$theta
      mmle_theta_est = TAM::tam.mml(
        modified_responses,
        xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff),
        item.elim = FALSE,
        verbose = FALSE
      )$person$EAP

      modified_responses %>%
        as_tibble() %>%
        mutate(
          id = paste0('00000', row_number()) %>% str_sub(-4, -1)
          , .before = 1
        ) %>%
        pivot_longer(
          cols = -id
          , names_to = 'item'
          , values_to = 'response'
        ) %>%
        winsteps_estimate(
          data = .
          , item_params = winsteps_item_diff
        )
      cmle_theta_est = winsteps_read_scores()

      eap_theta_est  =
        irtoys::ability(resp = modified_responses,
                        ip = list('est' = cbind(
                          1, modified_item_diff, 0, deparse.level = 0
                        )),
                        method = 'EAP')[, 1]

      thetas = cbind(person_theta,
                     prox_theta_est,
                     jmle_theta_est,
                     cmle_theta_est,
                     eap_theta_est)

      condition_5_estimates[[i+offset]] = list(Condition = condition_name, Theta = thetas)
      condition_5_responses[[i+offset]] = list(Condition = condition_name, ItemDiff = item_diff, Responses = responses)

      offset = offset + 1
    }
    
  }
}


saveRDS(condition_5_estimates, file = estimates_file_name)
saveRDS(condition_5_responses, file = responses_file_name)

```

### Normal Item, Bimodal Theta

```{r condition-6}
#| eval: true
#| output: false
# Conditions 73-90 Parameters
Start.time = Sys.time()

m_item = 0; m_person_1 = -1.5; m_person_2 = 1.5
sd_item = 1; sd_person = 0.5
estimates_file_name = 'simdata/06_bimodal_persons_estimates.RDS'
responses_file_name = 'simdata/06_bimodal_persons_responses.RDS'

condition_6_estimates = vector(mode = 'list', length = 18*iter)
condition_6_responses = vector(mode = 'list', length = 18*iter)
offset = 0

for (j in number_items) {
  print(paste0("Items: ", j))
  for (n in person_sample_sizes) {
    print(paste0("Persons: ", n))
    condition_name =
      tibble(
        Title = "Bimodal Persons"
        , ItemMean = m_item, ItemSD = sd_item
        , PersonMean = paste0(m_person_1, "; ", m_person_2), PersonSD = sd_person
        , N_Items = j
        , N_Person = n
        )
    for (i in 1:iter) {
      item_diff = round(rnorm(n = j, mean = m_item, sd = sd_item), 3)
      person_theta = rnorm(n = n, mean = c(m_person_1, m_person_2), sd = sd_person)

      responses = matrix(nrow = n, ncol = j)

      for (p in 1:n) {
        responses[p,] = rasch_response_sim(person_theta[p], item_diff)
      }

      zero_correct_items = which(colSums(responses) == 0 |
                                   colSums(responses) == n)
      if (length(zero_correct_items) > 0) {
        modified_responses = responses[, -zero_correct_items]
        modified_item_diff = item_diff[-zero_correct_items]
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      } else {
        modified_responses = responses
        modified_item_diff = item_diff
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      }

      prox_theta_est = prox_estimate(mean_item_diff = mean(item_diff),
                                     sd_item_diff = sd(item_diff),
                                     observed_raw_score = rowSums(responses),
                                     maximum_score = j)
      jmle_theta_est = TAM::tam.jml(
        modified_responses
        , xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff)
        , verbose = FALSE
      )$theta
      mmle_theta_est = TAM::tam.mml(
        modified_responses,
        xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff),
        item.elim = FALSE,
        verbose = FALSE
      )$person$EAP

      modified_responses %>%
        as_tibble() %>%
        mutate(
          id = paste0('00000', row_number()) %>% str_sub(-4, -1)
          , .before = 1
        ) %>%
        pivot_longer(
          cols = -id
          , names_to = 'item'
          , values_to = 'response'
        ) %>%
        winsteps_estimate(
          data = .
          , item_params = winsteps_item_diff
        )
      cmle_theta_est = winsteps_read_scores()

      eap_theta_est  =
        irtoys::ability(resp = modified_responses,
                        ip = list('est' = cbind(
                          1, modified_item_diff, 0, deparse.level = 0
                        )),
                        method = 'EAP')[, 1]

      thetas = cbind(person_theta,
                     prox_theta_est,
                     jmle_theta_est,
                     cmle_theta_est,
                     eap_theta_est)

      condition_6_estimates[[i+offset]] = list(Condition = condition_name, Theta = thetas)
      condition_6_responses[[i+offset]] = list(Condition = condition_name, ItemDiff = item_diff, Responses = responses)

      offset = offset + 1
    }
    
  }
}

saveRDS(condition_6_estimates, file = estimates_file_name)
saveRDS(condition_6_responses, file = responses_file_name)
```

### Bimodal Item, Normal Theta

```{r condition-6}
#| eval: true
#| output: false
# Conditions 73-90 Parameters
Start.time = Sys.time()

m_item_1 = -1.5; m_item_2 = 1.5; m_person = 0
sd_item = 0.5; sd_person = 1
estimates_file_name = 'simdata/06_bimodal_persons_estimates.RDS'
responses_file_name = 'simdata/06_bimodal_persons_responses.RDS'

condition_6_estimates = vector(mode = 'list', length = 18*iter)
condition_6_responses = vector(mode = 'list', length = 18*iter)
offset = 0

for (j in number_items) {
  print(paste0("Items: ", j))
  for (n in person_sample_sizes) {
    print(paste0("Persons: ", n))
    condition_name =
      tibble(
        Title = "Bimodal Items"
        , ItemMean = paste0(m_item_1, "; ", m_item_2), ItemSD = sd_item
        , PersonMean = m_person, PersonSD = sd_person
        , N_Items = j
        , N_Person = n
        )
    for (i in 1:iter) {
      item_diff = round(rnorm(n = j, mean = c(m_item_1, m_item_2), sd = sd_item), 3)
      person_theta = rnorm(n = n, mean = m_person, sd = sd_person)

      responses = matrix(nrow = n, ncol = j)

      for (p in 1:n) {
        responses[p,] = rasch_response_sim(person_theta[p], item_diff)
      }

      zero_correct_items = which(colSums(responses) == 0 |
                                   colSums(responses) == n)
      if (length(zero_correct_items) > 0) {
        modified_responses = responses[, -zero_correct_items]
        modified_item_diff = item_diff[-zero_correct_items]
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      } else {
        modified_responses = responses
        modified_item_diff = item_diff
        winsteps_item_diff = tibble(IRTb = modified_item_diff) %>%
          mutate(ItemID = paste0("V", row_number()))
      }

      prox_theta_est = prox_estimate(mean_item_diff = mean(item_diff),
                                     sd_item_diff = sd(item_diff),
                                     observed_raw_score = rowSums(responses),
                                     maximum_score = j)
      jmle_theta_est = TAM::tam.jml(
        modified_responses
        , xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff)
        , verbose = FALSE
      )$theta
      mmle_theta_est = TAM::tam.mml(
        modified_responses,
        xsi.fixed = cbind(1:length(modified_item_diff), modified_item_diff),
        item.elim = FALSE,
        verbose = FALSE
      )$person$EAP

      modified_responses %>%
        as_tibble() %>%
        mutate(
          id = paste0('00000', row_number()) %>% str_sub(-4, -1)
          , .before = 1
        ) %>%
        pivot_longer(
          cols = -id
          , names_to = 'item'
          , values_to = 'response'
        ) %>%
        winsteps_estimate(
          data = .
          , item_params = winsteps_item_diff
        )
      cmle_theta_est = winsteps_read_scores()

      eap_theta_est  =
        irtoys::ability(resp = modified_responses,
                        ip = list('est' = cbind(
                          1, modified_item_diff, 0, deparse.level = 0
                        )),
                        method = 'EAP')[, 1]

      thetas = cbind(person_theta,
                     prox_theta_est,
                     jmle_theta_est,
                     cmle_theta_est,
                     eap_theta_est)

      condition_7_estimates[[i+offset]] = list(Condition = condition_name, Theta = thetas)
      condition_7_responses[[i+offset]] = list(Condition = condition_name, ItemDiff = item_diff, Responses = responses)

      offset = offset + 1
    }
    
  }
}

saveRDS(condition_7_estimates, file = estimates_file_name)
saveRDS(condition_7_responses, file = responses_file_name)
```

## Analyzing the data

"Point-Estimate" methods to analyze the data:

  1. Correlation between true and estimated theta
  2. (Mean) Bias
  3. Mean Absolute Difference
  4. Mean Square Error
  5. Root Mean Square Error
  
done for each iteration of each condition. Then, these estimates can be averaged and a standard error of each measure calculated.

Using the "point estimate" for each condition as the DV, an ANOVA/LR can be used with the condition variables as IVs.

## Correlation

```{r correlation-between-estimates}
#| eval: false


mean_corr_list <- function(x) {
  Reduce("+", x) / length(x)
}

estimates_files_list <-
  paste0('simdata/', conditions$filename)
# short_file <-
#   list.files('simdata/', pattern = 'estimates')

loaded_estimates <-
  readRDS(estimates_files_list[1])

mean_correlation <-
  loaded_estimates %>%
  purrr::map('thetas') %>%
  purrr::map(cor) %>%
  mean_corr_list() %>% 
  as_tibble() %>%
  mutate(Condition = conditions$Condition[1], .before = 1) %>%
  mutate(Estimate = c("person_theta", "prox_theta_est", "jmle_theta_est", "cmle_theta_est", "eap_theat_est"), .after = 1) 

for (i in 2:length(estimates_files_list)) {
  loaded_estimates <-
    readRDS(estimates_files_list[i])
  test <-
    tryCatch(
      loaded_estimates %>%
        purrr::map('thetas') %>%
        purrr::map(as_tibble) %>%
        purrr::map(~.x %>% mutate_all(~ case_when((. == -Inf)|(is.na(.) & (sign(person_theta) == -1)) ~ -4, (. == Inf)|(is.na(.) & (sign(person_theta) == 1)) ~ 4, TRUE ~ .))) %>%
        purrr::map(cor) %>%
        mean_corr_list() %>% 
        as_tibble() %>%
        mutate(Condition = conditions$Condition[i], .before = 1) %>%
        mutate(Estimate = c("person_theta", "prox_theta_est", "jmle_theta_est", "cmle_theta_est", "eap_theat_est"), .after = 1)
        ,
      error = function(e)
        'error'
    )
  if ('tbl' %in% class(test)) {
    mean_correlation <-
      mean_correlation %>%
      bind_rows(
        test
      )
  } else
    if (test == 'error') {
    mean_correlation <-
      mean_correlation %>%
      bind_rows(
        loaded_estimates %>%
          purrr::map(as_tibble) %>%
          purrr::map(~.x %>% mutate_all(~ case_when((. == -Inf)|(is.na(.) & (sign(person_theta) == -1)) ~ -4, (. == Inf)|(is.na(.) & (sign(person_theta) == 1)) ~ 4, TRUE ~ .))) %>%
          purrr::map(cor) %>%
          mean_corr_list() %>%
          as_tibble() %>%
          mutate(Condition = conditions$Condition[i], .before = 1) %>%
          mutate(Estimate = c("person_theta", "prox_theta_est", "jmle_theta_est", "cmle_theta_est", "eap_theat_est"), .after = 1)
      )
  } else {
    stop("Something went wrong.")
  }
}

mean_correlation %>%
  select(-person_theta) %>%
  saveRDS('results/00_mean_correlation.RDS')
```
## "Point-Estimate"
### "Point-Estimate" functions
```{r analysis-critera-function}
#| eval: false

bias_estimator = function(data) {
  true_theta = data[,1]
  bias = c()
  
  data <- 
    data %>%
    as_tibble() %>%
    mutate(
      prox_theta_est =
        case_when(
          prox_theta_est == Inf | prox_theta_est > 4 ~ 4
          , prox_theta_est == -Inf | prox_theta_est < -4 ~ -4
          , TRUE ~ prox_theta_est
        )
      , cmle_theta_est =
        case_when(
          cmle_theta_est == Inf | cmle_theta_est > 4 ~ 4
          , cmle_theta_est == -Inf | cmle_theta_est < -4 ~ -4
        )
    ) 
  
  for (i in 2:ncol(data)) {
    numerator = sum(data[,i] - true_theta)
    
    bias_est = numerator / length(true_theta)
    
    bias = c(bias, bias_est)
  }
  names(bias) = paste0(colnames(data)[-1], "_bias")
  
  return(bias)
}

mad_estimator = function(data) {
  true_theta = data[,1]
  mad = c()
  
    data <- 
    data %>%
    as_tibble() %>%
    mutate(
      prox_theta_est =
        case_when(
          prox_theta_est == Inf | prox_theta_est > 4 ~ 4
          , prox_theta_est == -Inf | prox_theta_est < -4 ~ -4
          , TRUE ~ prox_theta_est
        )
      , cmle_theta_est =
        case_when(
          cmle_theta_est == Inf | cmle_theta_est > 4 ~ 4
          , cmle_theta_est == -Inf | cmle_theta_est < -4 ~ -4
          , TRUE ~ cmle_theta_est
        )
      , jmle_theta_est =
        case_when(
          jmle_theta_est == Inf | jmle_theta_est > 4 ~ 4
          , jmle_theta_est == -Inf | jmle_theta_est < -4 ~ -4
          , TRUE ~ jmle_theta_est
        )
      , eap_theta_est =
        case_when(
          eap_theta_est == Inf | eap_theta_est > 4 ~ 4
          , eap_theta_est == -Inf | eap_theta_est < -4 ~ -4
          , TRUE ~ eap_theta_est
        )
    ) 

  for (i in 2:ncol(data)) {
    numerator = sum(abs(data[,i] - true_theta))
    mad_est = numerator / (length(true_theta) - 1)
    
    mad = c(mad, mad_est)
  }
  names(mad) = paste0(colnames(data)[-1], "_mad")
  return(mad)
}

mse_estimator = function(data) {
  true_theta = data[,1]
  mse = c()
  
  data <- 
    data %>%
    as_tibble() %>%
    mutate(
      prox_theta_est =
        case_when(
          prox_theta_est == Inf | prox_theta_est > 4 ~ 4
          , prox_theta_est == -Inf | prox_theta_est < -4 ~ -4
          , TRUE ~ prox_theta_est
        )
      , cmle_theta_est =
        case_when(
          cmle_theta_est == Inf | cmle_theta_est > 4 ~ 4
          , cmle_theta_est == -Inf | cmle_theta_est < -4 ~ -4
          , TRUE ~ cmle_theta_est
        )
      , jmle_theta_est =
        case_when(
          jmle_theta_est == Inf | jmle_theta_est > 4 ~ 4
          , jmle_theta_est == -Inf | jmle_theta_est < -4 ~ -4
          , TRUE ~ jmle_theta_est
        )
      , eap_theta_est =
        case_when(
          eap_theta_est == Inf | eap_theta_est > 4 ~ 4
          , eap_theta_est == -Inf | eap_theta_est < -4 ~ -4
          , TRUE ~ eap_theta_est
        )
    ) 

  for (i in 2:ncol(data)) {
    numerator = sum((data[,i] - true_theta)^2)
    mse_est = numerator / (length(true_theta) - 1)
    
    mse = c(mse, mse_est)
  }
  
  names(mse) = paste0(colnames(data)[-1], "_mse")
  
  return(mse)
}

rmse_estimator = function(data) {
  true_theta = data[,1]
  rmse = c()
  
  data <- 
    data %>%
    as_tibble() %>%
    mutate(
      prox_theta_est =
        case_when(
          prox_theta_est == Inf | prox_theta_est > 4 ~ 4
          , prox_theta_est == -Inf | prox_theta_est < -4 ~ -4
          , TRUE ~ prox_theta_est
        )
      , cmle_theta_est =
        case_when(
          cmle_theta_est == Inf | cmle_theta_est > 4 ~ 4
          , cmle_theta_est == -Inf | cmle_theta_est < -4 ~ -4
          , TRUE ~ cmle_theta_est
        )
      , jmle_theta_est =
        case_when(
          jmle_theta_est == Inf | jmle_theta_est > 4 ~ 4
          , jmle_theta_est == -Inf | jmle_theta_est < -4 ~ -4
          , TRUE ~ jmle_theta_est
        )
      , eap_theta_est =
        case_when(
          eap_theta_est == Inf | eap_theta_est > 4 ~ 4
          , eap_theta_est == -Inf | eap_theta_est < -4 ~ -4
          , TRUE ~ eap_theta_est
        )
    ) 

  for (i in 2:ncol(data)) {
    numerator = sum((data[,i] - true_theta)^2)
    rmse_est = sqrt(numerator / (length(true_theta) - 1))
    
    rmse = c(rmse, rmse_est)
  }
  
  names(rmse) = paste0(colnames(data)[-1], "_rmse")

  return(rmse)
}

se_estimator = function(data) { # not vectorized like the others
  mean_est = mean(data, na.rm = TRUE)
  n = sum(!is.na(data))
  
  data_clean <- data[!is.na(data)]
  numerator = sum((data_clean - mean_est)^2)
  se_est = sqrt(numerator / (n - 1))
  
  return(se_est)
}

conditions <-
  readRDS("results/conditions.RDS")
```

### Mean Bias
```{r bias-estimates}
#| eval: false

loaded_estimates <-
  readRDS(estimates_files_list[1])

all_bias_estimates <-
  loaded_estimates %>%
  purrr::map('thetas') %>%
  purrr::map(bias_estimator) %>% 
  bind_rows() %>%
  mutate(filename = estimates_files_list[1] %>% str_remove("simdata/")) %>% 
  left_join(conditions)

for (i in 2:length(estimates_files_list)) {
  loaded_estimates <-
    readRDS(estimates_files_list[i])
  test <-
    tryCatch(
      purrr:::map(loaded_estimates, 'thetas') %>%
        purrr::map(bias_estimator)
        ,
      error = function(e)
        'error'
    )
  if (class(test) == 'list') {
    all_bias_estimates <-
      all_bias_estimates %>%
      bind_rows(
        purrr::map(loaded_estimates, 'thetas') %>%
          purrr::map(bias_estimator) %>%
          bind_rows() %>%
          mutate(filename = estimates_files_list[i] %>% str_remove("simdata/")) %>%
          left_join(conditions)
      )
  } else if (test == 'error') {
    all_bias_estimates <-
      all_bias_estimates %>%
      bind_rows(
        loaded_estimates %>%   
          purrr:::map(bias_estimator) %>%
          bind_rows() %>%
          mutate(filename = estimates_files_list[i] %>% str_remove("simdata/")) %>%
          left_join(conditions)
      )
  } else {
    stop("Something went wrong.")
  }
  
}

mean_bias_by_condition <-
  all_bias_estimates %>% 
  group_by(Condition) %>% 
  summarize(
    across(contains("_bias"), \(x) sum(!is.na(x)), .names = "n_{.col}")
    , across(contains("_bias"), \(x) mean(x, na.rm = TRUE), .names = "mean_{.col}")
            ) %>%
  select(-contains("mean_n_"))

se_bias_by_condition <-
  all_bias_estimates %>%
  group_by(Condition) %>%
  summarize(
    across(contains("_bias"), \(x) sum(!is.na(x)), .names = "n_{.col}")
    , across(contains("_bias"), \(x) se_estimator(x), .names = "se_{.col}")
  ) %>%
  select(-contains("se_n_"))
  

all_bias_estimates %>%
  saveRDS("results/01_all_bias_estimates.RDS")

mean_bias_by_condition %>%
  saveRDS("results/01_mean_bias_by_condition.RDS")

se_bias_by_condition %>%
  saveRDS('results/01_se_bias_estimates.RDS')

```

### Mean Absolute Difference
```{r mad-estimates}
#| eval: false

loaded_estimates <-
  readRDS(estimates_files_list[1])

all_mad_estimates <-
  loaded_estimates %>%
  purrr::map('thetas') %>%
  purrr::map(mad_estimator) %>% 
  bind_rows() %>%
  mutate(filename = estimates_files_list[1] %>% str_remove("simdata/")) %>% 
  left_join(conditions)

for (i in 2:length(estimates_files_list)) {
  loaded_estimates <-
    readRDS(estimates_files_list[i])
  test <-
    tryCatch(
      purrr:::map(loaded_estimates, 'thetas') %>%
        purrr::map(mad_estimator)
        ,
      error = function(e)
        'error'
    )
  if (class(test) == 'list') {
    all_mad_estimates <-
      all_mad_estimates %>%
      bind_rows(
        purrr::map(loaded_estimates, 'thetas') %>%
          purrr::map(mad_estimator) %>%
          bind_rows() %>%
          mutate(filename = estimates_files_list[i] %>% str_remove("simdata/")) %>%
          left_join(conditions)
      )
  } else if (test == 'error') {
    all_mad_estimates <-
      all_mad_estimates %>%
      bind_rows(
        loaded_estimates %>%   
          purrr:::map(mad_estimator) %>%
          bind_rows() %>%
          mutate(filename = estimates_files_list[i] %>% str_remove("simdata/")) %>%
          left_join(conditions)
      )
  } else {
    stop("Something went wrong.")
  }
  
}

mean_mad_by_condition <-
  all_mad_estimates %>% 
  group_by(Condition) %>% 
  summarize(
    across(contains("_mad"), \(x) sum(!is.na(x)), .names = "n_{.col}")
    , across(contains("_mad"), \(x) mean(x, na.rm = TRUE), .names = "mean_{.col}")
            ) %>%
  select(-contains("mean_n_"))

se_mad_by_condition <-
  all_mad_estimates %>%
  group_by(Condition) %>%
  summarize(
    across(contains("_mad"), \(x) sum(!is.na(x)), .names = "n_{.col}")
    , across(contains("_mad"), \(x) se_estimator(x), .names = "se_{.col}")
  ) %>%
  select(-contains("se_n_"))


all_mad_estimates %>%
  saveRDS("results/02_all_mad_estimates.RDS")

mean_mad_by_condition %>%
  saveRDS("results/02_mean_mad_by_condition.RDS")

se_mad_by_condition %>%
  saveRDS("results/02_se_mad_by_condition.RDS")
```

### Mean Square Error
```{r mse-estimates}
#| eval: false

loaded_estimates <-
  readRDS(estimates_files_list[1])

all_mse_estimates <-
  loaded_estimates %>%
  purrr::map('thetas') %>%
  purrr::map(mse_estimator) %>% 
  bind_rows() %>%
  mutate(filename = estimates_files_list[1] %>% str_remove("simdata/")) %>% 
  left_join(conditions)

for (i in 2:length(estimates_files_list)) {
  loaded_estimates <-
    readRDS(estimates_files_list[i])
  test <-
    tryCatch(
      purrr:::map(loaded_estimates, 'thetas') %>%
        purrr::map(mse_estimator)
        ,
      error = function(e)
        'error'
    )
  if (class(test) == 'list') {
    all_mse_estimates <-
      all_mse_estimates %>%
      bind_rows(
        purrr::map(loaded_estimates, 'thetas') %>%
          purrr::map(mse_estimator) %>%
          bind_rows() %>%
          mutate(filename = estimates_files_list[i] %>% str_remove("simdata/")) %>%
          left_join(conditions)
      )
  } else if (test == 'error') {
    all_mse_estimates <-
      all_mse_estimates %>%
      bind_rows(
        loaded_estimates %>%   
          purrr:::map(mse_estimator) %>%
          bind_rows() %>%
          mutate(filename = estimates_files_list[i] %>% str_remove("simdata/")) %>%
          left_join(conditions)
      )
  } else {
    stop("Something went wrong.")
  }
  
}

mean_mse_by_condition <-
  all_mse_estimates %>% 
  group_by(Condition) %>% 
  summarize(
    across(contains("_mse"), \(x) sum(!is.na(x)), .names = "n_{.col}")
    , across(contains("_mse"), \(x) mean(x, na.rm = TRUE), .names = "mean_{.col}")
            ) %>%
  select(-contains("mean_n_"))

se_mse_by_condition <-
  all_mse_estimates %>%
  group_by(Condition) %>%
  summarize(
    across(contains("_mse"), \(x) sum(!is.na(x)), .names = "n_{.col}")
    , across(contains("_mse"), \(x) se_estimator(x), .names = "se_{.col}")
  ) %>%
  select(-contains("se_n_"))
  

all_mse_estimates %>%
  saveRDS("results/03_all_mse_estimates.RDS")

mean_mse_by_condition %>%
  saveRDS("results/03_mean_mse_by_condition.RDS")

se_mse_by_condition %>%
  saveRDS('results/03_se_mse_estimates.RDS')

```

### Root Mean Square Error
```{r rmse-estimates}
#| eval: false

loaded_estimates <-
  readRDS(estimates_files_list[1])

all_rmse_estimates <-
  loaded_estimates %>%
  purrr::map('thetas') %>%
  purrr::map(rmse_estimator) %>% 
  bind_rows() %>%
  mutate(filename = estimates_files_list[1] %>% str_remove("simdata/")) %>% 
  left_join(conditions)

for (i in 2:length(estimates_files_list)) {
  loaded_estimates <-
    readRDS(estimates_files_list[i])
  test <-
    tryCatch(
      purrr:::map(loaded_estimates, 'thetas') %>%
        purrr::map(rmse_estimator)
        ,
      error = function(e)
        'error'
    )
  if (class(test) == 'list') {
    all_rmse_estimates <-
      all_rmse_estimates %>%
      bind_rows(
        purrr::map(loaded_estimates, 'thetas') %>%
          purrr::map(rmse_estimator) %>%
          bind_rows() %>%
          mutate(filename = estimates_files_list[i] %>% str_remove("simdata/")) %>%
          left_join(conditions)
      )
  } else if (test == 'error') {
    all_rmse_estimates <-
      all_rmse_estimates %>%
      bind_rows(
        loaded_estimates %>%   
          purrr:::map(rmse_estimator) %>%
          bind_rows() %>%
          mutate(filename = estimates_files_list[i] %>% str_remove("simdata/")) %>%
          left_join(conditions)
      )
  } else {
    stop("Something went wrong.")
  }
  
}

mean_rmse_by_condition <-
  all_rmse_estimates %>% 
  group_by(Condition) %>% 
  summarize(
    across(contains("_rmse"), \(x) sum(!is.na(x)), .names = "n_{.col}")
    , across(contains("_rmse"), \(x) mean(x, na.rm = TRUE), .names = "mean_{.col}")
            ) %>%
  select(-contains("mean_n_"))

se_rmse_by_condition <-
  all_rmse_estimates %>%
  group_by(Condition) %>%
  summarize(
    across(contains("_rmse"), \(x) sum(!is.na(x)), .names = "n_{.col}")
    , across(contains("_rmse"), \(x) se_estimator(x), .names = "se_{.col}")
  ) %>%
  select(-contains("se_n_"))
  

all_rmse_estimates %>%
  saveRDS("results/04_all_rmse_estimates.RDS")

mean_rmse_by_condition %>%
  saveRDS("results/04_mean_rmse_by_condition.RDS")

se_rmse_by_condition %>%
  saveRDS('results/04_se_rmse_estimates.RDS')

```

## Linear Models

```{r bias-anova}
#| eval: false

all_bias_estimates <-
  readRDS(file = 'results/01_all_bias_estimates.RDS') 
mean_bias_estimates <-
  readRDS(file = 'results/01_mean_bias_by_condition.RDS')
se_bias_estimates <-
  readRDS(file = 'results/01_se_bias_estimates.RDS')
long_bias_estimates <-
  all_bias_estimates %>%
  pivot_longer(
    cols = contains('_bias')
    , names_to = 'method_'
    , values_to = 'bias'
  ) %>%
  mutate(
    method_ = str_remove(method_, '_theta_est_bias') |> factor(levels = c("prox", "jmle", "cmle", "eap"))
    , Item_and_Person_Params = factor(Item_and_Person_Params)
  )

linear_model_bias <-
  lm(bias ~ Item_and_Person_Params * N * method_, data = long_bias_estimates) 

linear_model_bias %>%
  summary()
linear_model_bias %>%
  anova()

linear_model_bias %>%
  sjPlot::tab_model(
    show.intercept = FALSE
    , show.reflvl = TRUE
  )

```